<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>PathGen-Generative Tool</title>
    <style>

        @font-face {
            font-family: 'Klaster Sans';
            src: url('fonts/KlasterSans-Heavy.otf') format('opentype');
            font-weight: 800;
            font-style: normal;
            font-display: swap;
        }


        .credit {
            position: fixed;
            right: 16px;
            bottom: 12px;
            font-size: 10px;
            color: #ffffff;
            letter-spacing: 0.02em;
        }
        .credit a {
            color: #ffffff;
            text-decoration: none;
        }
        .credit a:hover { text-decoration: underline; }
        .lang-toggle {
            position: fixed;
            top: 14px;
            right: 14px;
            z-index: 10;
            width: auto;
            padding: 6px 10px;
            font-size: 10px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            border: 1px solid #000000;
            background: #84f51b;
            color: #000000;
        }
        :root { color-scheme: light; --panel-w: clamp(240px, 20vw, 320px); }
        html, body { margin: 0; height: 100%; overflow: hidden; background: #ffffff; }
        .layout { display: flex; height: 100vh; width: 100vw; background: #ffffff; }
        .stage { flex: 1 1 auto; position: relative; display: flex; align-items: center; justify-content: center; background: #000000; }
        canvas { display: block; }
        .brand {
            position: absolute;
            right: clamp(20px, 6vw, 140px);
            top: 50%;
            transform: translateY(-50%);
            font-family: 'Klaster Sans', sans-serif;
            font-weight: 800;
            font-size: clamp(36px, 10vw, 160px);
            letter-spacing: 0.02em;
            color: #ffffff;
            mix-blend-mode: difference;
            opacity: 0.85;
            pointer-events: none;
            transition: opacity 0.35s ease, transform 0.35s ease;
            text-align: right;
            white-space: nowrap;
        }
        .brand.is-hidden {
            opacity: 0;
            transform: translateY(-50%) translateX(24px);
        }
        @media (max-width: 900px) {
            .brand {
                right: 16px;
                top: 20%;
                transform: translateY(-20%);
                font-size: clamp(32px, 12vw, 110px);
                opacity: 0.8;
            }
        }
        .ui {
            flex: 0 0 var(--panel-w);
            width: var(--panel-w);
            font: 10px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background: #84f51b;
            padding: 16px 16px 12px 16px;
            overflow: hidden;
            user-select: none;
            color: #000000;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: left;
            height: 100%;
            box-sizing: border-box;
        }
.title {
            font-family: 'Klaster Sans', sans-serif;
            font-weight: 800;
            font-size: 80px;
            letter-spacing: 0.02em;
            color: #000000;
            width: 100%;
            max-width: var(--panel-w);
            box-sizing: border-box;
            margin: 0 0 16px 0;
        }

        .controls {
            flex: 1 1 auto;
            overflow-y: auto;
            min-height: 0;
            padding-right: 6px;
            width: 100%;
            max-width: var(--panel-w);
            box-sizing: border-box;
            align-self: center;
        }
        .ui-footer {
            margin-top: auto;
            padding-top: 12px;
            width: 100%;
            max-width: var(--panel-w);
            box-sizing: border-box;
            align-self: center;
        }
        .support {
            margin-top: 10px;
            width: 100%;
        }
        .support-panel {
            display: none;
            margin-top: 8px;
            border: 1px solid #000000;
            padding: 6px;
            background: #84f51b;
            box-sizing: border-box;
        }
        .support-panel.is-open { display: block; }
        .support-text {
            font-size: 9px;
            line-height: 1.35;
            color: #000000;
            margin-bottom: 6px;
        }
        .support-panel img {
            width: 100%;
            height: auto;
            display: block;
        }
        .row label, .row span { color: #000000; }
        .row { display: flex; flex-direction: column; align-items: flex-start; gap: 6px; margin: 10px 0; }
        .row label { width: auto; opacity: 1; }
        .row input[type="range"] { width: 100%; }
        .row input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border: 1px solid #000000;
            border-radius: 0;
            background: #84f51b;
        }
        .row input[type="checkbox"]:checked {
            background: #000000;
        }
        .row span { align-self: flex-end; }
        .row.inline { flex-direction: row; align-items: center; justify-content: space-between; }
        .row.inline label { margin-right: 10px; }
        .row.inline .inline-right { display: flex; align-items: center; justify-content: flex-end; gap: 8px; width: 80px; }
        .group {
            margin-bottom: 10px;
            padding: 15px;
            border: 1px solid #000000;
            width: 100%;
            max-width: var(--panel-w);
            box-sizing: border-box;
        }
        .group-title { 
            font-size: 13px; 
            letter-spacing: 0.06em; 
            text-transform: uppercase; 
            opacity: 1; 
            color: #000000;
            margin-bottom: 20px;
        }
        .group-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
        .group-header .group-title { margin-bottom: 0; }
        .group-toggle {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border: 1px solid #000000;
            border-radius: 0;
            background: #84f51b;
        }
        .group-toggle:checked { background: #000000; }
        .group.is-off .group-body { display: none; }
        .group.is-off .group-header { margin-bottom: 0; }
        .row.inline span { align-self: center; }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 1px;
            background: #000000;
            border-radius: 0;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #000000;
            border-radius: 0;
            border: none;
        }
        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #000000;
            border-radius: 0;
            border: none;
        }
        input[type="range"]::-moz-range-track {
            height: 1px;
            background: #000000;
            border: none;
        }
        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            width: 80px;
            height: 16px;
            padding: 0;
            border: 1px solid #000000;
            background: #000000;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
        }
        input[type="file"] {
            border: 1px solid #000000;
            background: #84f51b;
            color: #000000;
            padding: 4px 6px;
            border-radius: 0;
            font: inherit;
            box-sizing: border-box;
        }
        .file-line { width: 100%; }
        .file-line input[type="file"] { width: 100%; box-sizing: border-box; }
        .file-line button { width: 100%; box-sizing: border-box; padding: 6px 10px; font-size: 9px; margin-top: 6px; }
        select {
            width: 100%;
            border: 1px solid #000000;
            background: #84f51b;
            color: #000000;
            padding: 4px 6px;
            border-radius: 0;
            font: inherit;
        }
        .hint { margin-top: 5px; font-size: 9px; color: #000000; opacity: 1; text-align: center; }
        .btns { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px; width: 100%; box-sizing: border-box; }
        .ui.is-hidden { flex-basis: 0; width: 0; padding: 0; opacity: 0; pointer-events: none; }
        .resizer {
            width: 8px;
            cursor: col-resize;
            background: #84f51b;
            position: relative;
        }
        .resizer::after {
            content: "";
            position: absolute;
            top: 0;
            bottom: 0;
            left: 3px;
            width: 2px;
            background: #000000;
            opacity: 0.2;
        }
        .resizer:hover::after,
        .resizer.is-dragging::after { opacity: 0.6; }
        button {
            border: none;
            background: #000000;
            padding: 10px 16px;
            font: inherit;
            cursor: pointer;
            width: 100%;
            color: #ffffff;
        }
        button.lang-toggle {
            width: auto;
            padding: 6px 10px;
            border: 1px solid #000000;
            background: #84f51b;
            color: #000000;
        }
        button:active { transform: translateY(1px); }
        @media (max-width: 900px) {
            .layout { flex-direction: column; }
            :root { --panel-w: 100%; }
            .ui { flex: 0 0 auto; width: 100%; max-height: 50vh; }
            .controls { max-width: 100%; padding-right: 0; }
            .ui-footer { max-width: 100%; }
            .group { max-width: 100%; }
            .resizer { display: none; }
            .stage { flex: 1 1 auto; }
        }
    </style>
</head>
<body>
    <button id="langToggle" class="lang-toggle" type="button">中文</button>
    <div class="layout">
      <div class="ui">
        <div class="controls">
        <div class="group line-group">
          <div class="group-header">
            <div class="group-title" data-i18n="groupLine">Line</div>
            <input id="lineToggle" class="group-toggle" type="checkbox" checked>
          </div>
          <div class="group-body">
            <div class="row">
              <label data-i18n="labelStroke">Stroke</label>
              <input id="stroke" type="range" min="0.5" max="100" step="0.1" value="4">
              <span id="strokeVal">4.0</span>
            </div>

            <div class="row">
              <label data-i18n="labelLineStyle">Line Style</label>
              <input id="lineStyle" type="range" min="0" max="9" step="1" value="0">
              <span id="lineStyleVal">Solid</span>
            </div>

            <div class="row">
              <label data-i18n="labelQuality">Quality</label>
              <input id="quality" type="range" min="1" max="4" step="1" value="3">
              <span id="qualityVal">3</span>
            </div>

            <div class="row">
              <label data-i18n="labelDetail">Detail</label>
              <input id="detail" type="range" min="0" max="6" step="1" value="3">
              <span id="detailVal">3</span>
            </div>

            <div class="row">
              <label data-i18n="labelOrganic">Organic</label>
              <input id="organic" type="range" min="0" max="100" step="1" value="100">
              <span id="organicVal">100%</span>
            </div>

            <div class="row">
              <label data-i18n="labelRange">Range</label>
              <input id="range" type="range" min="10" max="100" step="1" value="100">
              <span id="rangeVal">100%</span>
            </div>

            <div class="row">
              <label data-i18n="labelSpeed">Speed</label>
              <input id="speed" type="range" min="0.2" max="2.5" step="0.1" value="0.5">
              <span id="speedVal">0.5</span>
            </div>

            <div class="row">
              <label data-i18n="labelTrail">Trail</label>
              <input id="trail" type="range" min="0" max="0.95" step="0.01" value="0">
              <span id="trailVal">0%</span>
            </div>

            <div class="row">
              <label data-i18n="labelBreath">Breath</label>
              <input id="breath" type="range" min="0" max="1" step="0.01" value="0.2">
              <span id="breathVal">0.20</span>
            </div>

            <div class="row">
              <label data-i18n="labelJitter">Jitter</label>
              <input id="lineJitter" type="range" min="0" max="1" step="0.01" value="0">
              <span id="lineJitterVal">0.00</span>
            </div>

            <div class="row">
              <label data-i18n="labelLayers">Layers</label>
              <input id="layers" type="range" min="1" max="5" step="1" value="1">
              <span id="layersVal">1</span>
            </div>

          <div class="row inline">
            <label data-i18n="labelGradient">Gradient</label>
            <div class="inline-right">
              <input id="gradient" type="checkbox">
            </div>
          </div>

          <div class="row">
            <label data-i18n="labelGradientDepth">Gradient Depth</label>
            <input id="gradDepth" type="range" min="0" max="0.8" step="0.01" value="0.35">
            <span id="gradDepthVal">0.35</span>
          </div>

          <div class="row">
            <label data-i18n="labelGradientSpeed">Gradient Speed</label>
            <input id="gradSpeed" type="range" min="0" max="3" step="0.1" value="0.6">
            <span id="gradSpeedVal">0.6</span>
          </div>
          </div>
        </div>

        <div class="group node-group">
          <div class="group-header">
            <div class="group-title" data-i18n="groupNodes">Nodes</div>
            <input id="nodesToggle" class="group-toggle" type="checkbox">
          </div>
          <div class="group-body">
            <div class="row">
              <label data-i18n="labelNodes">Nodes</label>
              <input id="nodes" type="range" min="0" max="60" step="1" value="12">
              <span id="nodesVal">12</span>
            </div>

            <div class="row">
                <label data-i18n="labelNodeShape">Node Shape</label>
                <input id="shape" type="range" min="0" max="18" step="1" value="2">
                <span id="shapeVal">Circle</span>
              </div>

          <div class="row">
            <label data-i18n="labelNodeSize">Node Size</label>
            <input id="shapeSize" type="range" min="3" max="60" step="1" value="6">
            <span id="shapeSizeVal">6</span>
          </div>
          <div class="row">
            <label data-i18n="labelNodeStroke">Node Stroke</label>
            <input id="nodeStroke" type="range" min="0.5" max="6" step="0.1" value="1">
            <span id="nodeStrokeVal">1.0</span>
          </div>

          <div class="row">
            <label data-i18n="labelNodeDrift">Node Drift</label>
            <input id="nodeDrift" type="range" min="0" max="1" step="0.01" value="0.2">
            <span id="nodeDriftVal">0.20</span>
          </div>

          <div class="row inline">
            <label data-i18n="labelInteract">Interact</label>
            <div class="inline-right">
              <input id="nodeInteract" type="checkbox">
            </div>
          </div>

          <div class="row">
            <label data-i18n="labelForce">Force</label>
            <input id="nodeForce" type="range" min="0" max="1" step="0.01" value="0.3">
            <span id="nodeForceVal">0.30</span>
          </div>

          <div class="row">
            <label data-i18n="labelRadius">Radius</label>
            <input id="nodeRadius" type="range" min="50" max="400" step="10" value="160">
            <span id="nodeRadiusVal">160</span>
          </div>

          <div class="row inline">
            <label data-i18n="labelRepel">Repel</label>
            <div class="inline-right">
              <input id="nodeRepel" type="checkbox">
            </div>
          </div>

          <div class="row inline">
              <label data-i18n="labelFill">Fill</label>
              <div class="inline-right">
                <input id="fill" type="checkbox" checked>
              </div>
            </div>

            <div class="row inline">
              <label data-i18n="labelNumber">Number</label>
              <div class="inline-right">
                <input id="labels" type="checkbox">
              </div>
            </div>
          </div>
        </div>

        <div class="group other-group">
          <div class="row inline">
            <label data-i18n="labelBackground">Background Colour</label>
            <div class="inline-right">
              <input id="bgColor" type="color" value="#000000">
            </div>
          </div>
          <div class="row inline">
            <label data-i18n="labelStrokeColor">Stroke Colour</label>
            <div class="inline-right">
              <input id="strokeColor" type="color" value="#ffffff">
            </div>
          </div>
          <div class="row inline">
            <label data-i18n="labelNodeColor">Node Colour</label>
            <div class="inline-right">
              <input id="nodeColor" type="color" value="#ffffff">
            </div>
          </div>
          <div class="row">
            <label data-i18n="labelBackgroundImage">Background Image</label>
            <div class="file-line">
              <input id="bgImage" type="file" accept="image/*">
              <button id="clearBg" type="button" data-i18n="buttonClear">Clear</button>
            </div>
          </div>
          <div class="row">
            <label data-i18n="labelCanvasSize">Canvas Size</label>
            <select id="canvasSize">
              <option value="window" data-i18n="optionWindow">Window</option>
              <option value="1080x1960">1080x1960</option>
              <option value="1080x1340">1080x1340</option>
              <option value="1080x1440">1080x1440</option>
            </select>
          </div>
        </div>
        </div>

        <div class="ui-footer">
          <div class="btns">
            <button id="regen" data-i18n="buttonReset">Reset</button>
            <button id="pause" data-i18n="buttonPause">Pause</button>
            <button id="download" data-i18n="buttonDownload">Download</button>
            <button id="record" data-i18n="buttonRecord">Record</button>
          </div>

          <div class="hint" data-i18n-html="hint">
          <b>R</b> regenerate · <b>Space</b> pause · <b>H</b> hide panel
          </div>

          <div class="support">
            <button id="supportToggle" type="button" data-i18n="buttonSupport">Support PathGen</button>
            <div class="support-panel" id="supportPanel">
              <div class="support-text">
                <div data-i18n="supportLine1">PathGen is free and open to use.</div>
                <div data-i18n-html="supportLine2">If you find it helpful, you can support me via <a href="https://buymeacoffee.com/luoooyf" target="_blank" rel="noopener">Buy Me a Coffee</a>.</div>
              </div>
              <img id="supportImage" src="support.jpg" alt="support">
            </div>
          </div>
        </div>
      </div>
      <div class="resizer" id="resizer" title="Drag to resize"></div>
      <div class="stage" id="stage">
        <div class="brand" id="brand">PathGen</div>
        <canvas id="canvas"></canvas>
      </div>
    </div>

<script>
let FG = "#ffffff";
let BG = "#000000";
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const stage = document.getElementById('stage');
const elRecord = document.getElementById("record");
const supportToggle = document.getElementById("supportToggle");
const supportPanel = document.getElementById("supportPanel");
const supportImage = document.getElementById("supportImage");
const resizer = document.getElementById("resizer");
const brand = document.getElementById("brand");
const panel = document.querySelector(".ui");
const langToggle = document.getElementById("langToggle");

let currentLang = "en";
const i18n = {
    en: {
        groupLine: "Line",
        labelStroke: "Stroke",
        labelLineStyle: "Line Style",
        labelQuality: "Quality",
        labelDetail: "Detail",
        labelOrganic: "Organic",
        labelRange: "Range",
        labelSpeed: "Speed",
        labelTrail: "Trail",
        labelBreath: "Breath",
        labelJitter: "Jitter",
        labelLayers: "Layers",
        labelGradient: "Gradient",
        labelGradientDepth: "Gradient Depth",
        labelGradientSpeed: "Gradient Speed",
        groupNodes: "Nodes",
        labelNodes: "Nodes",
        labelNodeShape: "Node Shape",
        labelNodeSize: "Node Size",
        labelNodeStroke: "Node Stroke",
        labelNodeDrift: "Node Drift",
        labelInteract: "Interact",
        labelForce: "Force",
        labelRadius: "Radius",
        labelRepel: "Repel",
        labelFill: "Fill",
        labelNumber: "Number",
        labelBackground: "Background Colour",
        labelStrokeColor: "Stroke Colour",
        labelNodeColor: "Node Colour",
        labelBackgroundImage: "Background Image",
        labelCanvasSize: "Canvas Size",
        buttonClear: "Clear",
        optionWindow: "Window",
        buttonReset: "Reset",
        buttonPause: "Pause",
        buttonDownload: "Download",
        buttonRecord: "Record",
        buttonSupport: "Support PathGen",
        hint: "<b>R</b> regenerate · <b>Space</b> pause · <b>H</b> hide panel",
        supportLine1: "PathGen is free and open to use.",
        supportLine2: "If you find it helpful, you can support me via <a href=\"https://buymeacoffee.com/luoooyf\" target=\"_blank\" rel=\"noopener\">Buy Me a Coffee</a>."
    },
    cn: {
        groupLine: "线条",
        labelStroke: "线宽",
        labelLineStyle: "线条样式",
        labelQuality: "质量",
        labelDetail: "细节",
        labelOrganic: "自然度",
        labelRange: "范围",
        labelSpeed: "速度",
        labelTrail: "残影",
        labelBreath: "呼吸",
        labelJitter: "抖动",
        labelLayers: "层数",
        labelGradient: "渐变",
        labelGradientDepth: "渐变深度",
        labelGradientSpeed: "渐变速度",
        groupNodes: "节点",
        labelNodes: "节点数量",
        labelNodeShape: "节点形状",
        labelNodeSize: "节点大小",
        labelNodeStroke: "节点描边",
        labelNodeDrift: "节点漂移",
        labelInteract: "交互",
        labelForce: "力度",
        labelRadius: "半径",
        labelRepel: "排斥",
        labelFill: "填充",
        labelNumber: "编号",
        labelBackground: "背景颜色",
        labelStrokeColor: "线条颜色",
        labelNodeColor: "节点颜色",
        labelBackgroundImage: "背景图片",
        labelCanvasSize: "画布尺寸",
        buttonClear: "清除",
        optionWindow: "窗口",
        buttonReset: "重置",
        buttonPause: "暂停",
        buttonDownload: "下载",
        buttonRecord: "录制",
        buttonSupport: "支持 PathGen",
        hint: "<b>R</b> 重新生成 · <b>Space</b> 暂停 · <b>H</b> 隐藏面板",
        supportLine1: "PathGen 保持公开使用。",
        supportLine2: "如果你觉得这个工具对你有帮助，可以通过微信赞赏支持一下维护成本（按需即可）。"
    }
};
const lineNamesByLang = {
    en: ["Solid", "Particles", "Dashed", "Blocks", "Multi", "Stipple", "Pulse", "Zigzag", "Double", "Jitter"],
    cn: ["实线", "颗粒", "虚线", "块状", "多段", "点描", "脉冲", "之字", "双线", "抖动"]
};
const shapeNamesByLang = {
    en: [
        "Cross",
        "Triangle",
        "Circle",
        "Square",
        "Coda",
        "Empty Set",
        "Square Dot",
        "Diamond",
        "Hexagon",
        "Star",
        "Pentagon",
        "Octagon",
        "Ring",
        "Plus",
        "Minus",
        "Triangle Up",
        "Triangle Down",
        "Heart",
        "Arrow"
    ],
    cn: [
        "十字",
        "三角形",
        "圆形",
        "方形",
        "尾标",
        "空集",
        "方点",
        "菱形",
        "六边形",
        "星形",
        "五边形",
        "八边形",
        "圆环",
        "加号",
        "减号",
        "上三角",
        "下三角",
        "心形",
        "箭头"
    ]
};

function applyI18n() {
    const dict = i18n[currentLang] || i18n.en;
    document.querySelectorAll("[data-i18n]").forEach(el => {
        const key = el.getAttribute("data-i18n");
        if (dict[key]) el.textContent = dict[key];
    });
    document.querySelectorAll("[data-i18n-html]").forEach(el => {
        const key = el.getAttribute("data-i18n-html");
        if (dict[key]) el.innerHTML = dict[key];
    });
    if (langToggle) {
        langToggle.textContent = currentLang === "en" ? "中文" : "EN";
    }
    if (supportImage) {
        supportImage.style.display = currentLang === "cn" ? "block" : "none";
    }
    syncUI();
}

function setLang(next) {
    currentLang = next;
    applyI18n();
}

if (brand && panel) {
    ["input", "change", "pointerdown"].forEach(ev => {
        panel.addEventListener(ev, () => {
            brand.classList.add("is-hidden");
        }, { once: true, capture: true });
    });
}

if (brand) {
    setTimeout(() => {
        brand.classList.add("is-hidden");
    }, 2000);
}

if (supportToggle && supportPanel) {
    supportToggle.addEventListener("click", () => {
        supportPanel.classList.toggle("is-open");
    });
}
if (langToggle) {
    langToggle.addEventListener("click", () => {
        const next = currentLang === "en" ? "cn" : "en";
        setLang(next);
    });
}

let width, height;
let pathPoints = []; 
let anchors = [];    
let markers = []; 
let maxMarkers = 12;
let paused = false;
let timeSec = 0;
const mouse = { x: 0, y: 0, active: false };
let bgImage = null;

stage.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
    mouse.active = true;
});
stage.addEventListener("mouseleave", () => {
    mouse.active = false;
});

let isResizing = false;
resizer.addEventListener("mousedown", (e) => {
    e.preventDefault();
    isResizing = true;
    resizer.classList.add("is-dragging");
});
window.addEventListener("mousemove", (e) => {
    if (!isResizing) return;
    const min = 180;
    const max = Math.max(420, Math.floor(window.innerWidth * 0.6));
    const next = Math.max(min, Math.min(max, e.clientX));
    document.documentElement.style.setProperty("--panel-w", `${next}px`);
    resize({ reset: false });
});
window.addEventListener("mouseup", () => {
    if (!isResizing) return;
    isResizing = false;
    resizer.classList.remove("is-dragging");
});

let mediaRecorder;
let recordedChunks = [];

elRecord.addEventListener("click", () => {
    recordedChunks = [];

    const stream = canvas.captureStream(60);
    mediaRecorder = new MediaRecorder(stream, {
        mimeType: "video/webm; codecs=vp9"
    });

    mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
    };

    mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = `dot10_motion_${Date.now()}.webm`;
        a.click();

        URL.revokeObjectURL(url);
    };

    mediaRecorder.start();

    setTimeout(() => {
        mediaRecorder.stop();
    }, 2000);
});

const ui = {
    stroke: document.getElementById("stroke"),
    strokeVal: document.getElementById("strokeVal"),
    strokeColor: document.getElementById("strokeColor"),
    lineStyle: document.getElementById("lineStyle"),
    lineStyleVal: document.getElementById("lineStyleVal"),
    quality: document.getElementById("quality"),
    qualityVal: document.getElementById("qualityVal"),
    nodes: document.getElementById("nodes"),
    nodesVal: document.getElementById("nodesVal"),
    detail: document.getElementById("detail"),
    detailVal: document.getElementById("detailVal"),
    organic: document.getElementById("organic"),
    organicVal: document.getElementById("organicVal"),
    range: document.getElementById("range"),
    rangeVal: document.getElementById("rangeVal"),
    speed: document.getElementById("speed"),
    speedVal: document.getElementById("speedVal"),
    trail: document.getElementById("trail"),
    trailVal: document.getElementById("trailVal"),
    breath: document.getElementById("breath"),
    breathVal: document.getElementById("breathVal"),
    lineJitter: document.getElementById("lineJitter"),
    lineJitterVal: document.getElementById("lineJitterVal"),
    layers: document.getElementById("layers"),
    layersVal: document.getElementById("layersVal"),
    gradient: document.getElementById("gradient"),
    gradDepth: document.getElementById("gradDepth"),
    gradDepthVal: document.getElementById("gradDepthVal"),
    gradSpeed: document.getElementById("gradSpeed"),
    gradSpeedVal: document.getElementById("gradSpeedVal"),
    lineToggle: document.getElementById("lineToggle"),
    shape: document.getElementById("shape"),
    shapeVal: document.getElementById("shapeVal"),
    shapeSize: document.getElementById("shapeSize"),
    shapeSizeVal: document.getElementById("shapeSizeVal"),
    nodeColor: document.getElementById("nodeColor"),
    nodeStroke: document.getElementById("nodeStroke"),
    nodeStrokeVal: document.getElementById("nodeStrokeVal"),
    nodeDrift: document.getElementById("nodeDrift"),
    nodeDriftVal: document.getElementById("nodeDriftVal"),
    nodeInteract: document.getElementById("nodeInteract"),
    nodeForce: document.getElementById("nodeForce"),
    nodeForceVal: document.getElementById("nodeForceVal"),
    nodeRadius: document.getElementById("nodeRadius"),
    nodeRadiusVal: document.getElementById("nodeRadiusVal"),
    nodeRepel: document.getElementById("nodeRepel"),
    nodesToggle: document.getElementById("nodesToggle"),
    fill: document.getElementById("fill"),
    labels: document.getElementById("labels"),
    regen: document.getElementById("regen"),
    pause: document.getElementById("pause"),
    download: document.getElementById("download"),
    bgColor: document.getElementById("bgColor"),
    strokeColor: document.getElementById("strokeColor"),
    canvasSize: document.getElementById("canvasSize"),
    bgImage: document.getElementById("bgImage"),
    clearBg: document.getElementById("clearBg")
};

function syncUI() {
    ui.strokeVal.textContent = (+ui.stroke.value).toFixed(1);
    const lineNames = lineNamesByLang[currentLang] || lineNamesByLang.en;
    ui.lineStyleVal.textContent = lineNames[parseInt(ui.lineStyle.value, 10)] || lineNames[0];
    ui.qualityVal.textContent = ui.quality.value;
    ui.nodesVal.textContent = ui.nodes.value;
    ui.detailVal.textContent = ui.detail.value;
    ui.organicVal.textContent = `${ui.organic.value}%`;
    ui.rangeVal.textContent = `${ui.range.value}%`;
    ui.speedVal.textContent = (+ui.speed.value).toFixed(1);
    ui.trailVal.textContent = `${Math.round(parseFloat(ui.trail.value) * 100)}%`;
    ui.breathVal.textContent = (+ui.breath.value).toFixed(2);
    ui.lineJitterVal.textContent = (+ui.lineJitter.value).toFixed(2);
    ui.layersVal.textContent = ui.layers.value;
    ui.gradDepthVal.textContent = (+ui.gradDepth.value).toFixed(2);
    ui.gradSpeedVal.textContent = (+ui.gradSpeed.value).toFixed(1);
    const shapeIdx = parseInt(ui.shape.value, 10);
    const names = shapeNamesByLang[currentLang] || shapeNamesByLang.en;
    ui.shapeVal.textContent = names[shapeIdx] || names[0];
    ui.shapeSizeVal.textContent = ui.shapeSize.value;
    ui.nodeStrokeVal.textContent = (+ui.nodeStroke.value).toFixed(1);
    ui.nodeDriftVal.textContent = (+ui.nodeDrift.value).toFixed(2);
    ui.nodeForceVal.textContent = (+ui.nodeForce.value).toFixed(2);
    ui.nodeRadiusVal.textContent = ui.nodeRadius.value;
    requestRedraw();
}

["input","change"].forEach(ev => {
    ui.stroke.addEventListener(ev, syncUI);
    ui.strokeColor.addEventListener(ev, syncUI);
    ui.lineStyle.addEventListener(ev, syncUI);
    ui.quality.addEventListener(ev, syncUI);
    ui.nodes.addEventListener(ev, syncUI);
    ui.detail.addEventListener(ev, () => { syncUI(); regenerate(); });
    ui.organic.addEventListener(ev, syncUI);
    ui.range.addEventListener(ev, () => { syncUI(); regenerate(); });
    ui.speed.addEventListener(ev, syncUI);
    ui.trail.addEventListener(ev, syncUI);
    ui.breath.addEventListener(ev, syncUI);
    ui.lineJitter.addEventListener(ev, syncUI);
    ui.layers.addEventListener(ev, syncUI);
    ui.gradient.addEventListener(ev, syncUI);
    ui.gradDepth.addEventListener(ev, syncUI);
    ui.gradSpeed.addEventListener(ev, syncUI);
    ui.shape.addEventListener(ev, syncUI);
    ui.shapeSize.addEventListener(ev, syncUI);
    ui.nodeStroke.addEventListener(ev, syncUI);
    ui.nodeDrift.addEventListener(ev, syncUI);
    ui.nodeInteract.addEventListener(ev, syncUI);
    ui.nodeForce.addEventListener(ev, syncUI);
    ui.nodeRadius.addEventListener(ev, syncUI);
    ui.nodeRepel.addEventListener(ev, syncUI);
    ui.fill.addEventListener(ev, syncUI);
    ui.labels.addEventListener(ev, syncUI);
    ui.bgColor.addEventListener(ev, applyTheme);
    ui.strokeColor.addEventListener(ev, applyTheme);
    ui.nodesToggle.addEventListener(ev, syncNodesGroup);
    ui.lineToggle.addEventListener(ev, syncLineGroup);
    ui.nodeColor.addEventListener(ev, syncUI);
    ui.canvasSize.addEventListener(ev, () => resize({ reset: false }));
    ui.bgImage.addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) {
            bgImage = null;
            requestRedraw();
            return;
        }
        const reader = new FileReader();
        reader.onload = () => {
            const img = new Image();
            img.onload = () => {
                bgImage = img;
                requestRedraw();
            };
            img.src = reader.result;
        };
        reader.readAsDataURL(file);
    });
    ui.clearBg.addEventListener("click", () => {
        bgImage = null;
        ui.bgImage.value = "";
        requestRedraw();
    });
});
applyI18n();
syncNodesGroup();
syncLineGroup();

function syncNodesGroup() {
    const group = document.querySelector(".node-group");
    const enabled = ui.nodesToggle?.checked;
    if (group) group.classList.toggle("is-off", !enabled);
    if (!enabled) {
        markers = [];
    }
}

function syncLineGroup() {
    const group = document.querySelector(".line-group");
    const enabled = ui.lineToggle?.checked;
    if (group) group.classList.toggle("is-off", !enabled);
}

function applyTheme() {
    document.documentElement.style.setProperty("color-scheme", "light");
    BG = ui.bgColor?.value || "#000000";
    FG = ui.strokeColor?.value || "#ffffff";
    document.body.style.background = "#ffffff";
    if (stage) stage.style.background = "#000000";

    if (paused) {
        draw();
    }

    const panel = document.querySelector(".ui");
    if (panel) {
        panel.style.background = "#84f51b";
        panel.style.color = "#000000";
        panel.style.border = "1px solid rgba(0,0,0,0.12)";
    }

    document.querySelectorAll(".row label, .row span, .hint").forEach(el => {
        el.style.color = "#000000";
    });

    document.querySelectorAll("button").forEach(btn => {
        if (btn.classList.contains("lang-toggle")) return;
        btn.style.background = "#000000";
        btn.style.color = "#ffffff";
        btn.style.border = "none";
    });

    document.querySelectorAll('input[type="range"]').forEach(r => {
        r.style.background = "#000000";
    });

    requestRedraw();
}
applyTheme();

function resize({ reset = true } = {}) {
    const rect = stage.getBoundingClientRect();
    const preset = ui.canvasSize?.value || "window";
    if (preset === "window") {
        width = canvas.width = Math.max(1, Math.floor(rect.width));
        height = canvas.height = Math.max(1, Math.floor(rect.height));
        canvas.style.width = "100%";
        canvas.style.height = "100%";
    } else {
        const parts = preset.split("x");
        const w = parseInt(parts[0], 10);
        const h = parseInt(parts[1], 10);
        width = canvas.width = Math.max(1, w || rect.width);
        height = canvas.height = Math.max(1, h || rect.height);
        const scale = Math.min(rect.width / width, rect.height / height);
        canvas.style.width = `${Math.floor(width * scale)}px`;
        canvas.style.height = `${Math.floor(height * scale)}px`;
    }
    if (reset) initAnchors();
    requestRedraw();
}
window.addEventListener('resize', resize);
function requestRedraw() {
    if (paused) draw();
}

function initAnchors() {
    anchors = [];
    const detail = parseInt(ui.detail.value, 10);
    const count = detail === 0 ? 2 : Math.round(4 + detail * 2);
    const range = parseFloat(ui.range.value) / 100;
    const areaW = width * range;
    const areaH = height * range;
    const minX = (width - areaW) / 2;
    const minY = (height - areaH) / 2;
    const maxX = minX + areaW;
    const maxY = minY + areaH;
    for (let i = 0; i < count; i++) {
        anchors.push({
            x: minX + Math.random() * (maxX - minX),
            y: minY + Math.random() * (maxY - minY),
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            ax: 0,
            ay: 0,
            friction: 0.98 
        });
    }
}

function updateMarkers() {

    if (!ui.nodesToggle?.checked) {
        markers = [];
        return;
    }
    maxMarkers = parseInt(ui.nodes.value, 10);
    if (markers.length !== maxMarkers) {
        const next = [];
        for (let i = 0; i < maxMarkers; i++) {
            const ratio = maxMarkers <= 1 ? Math.random() : i / maxMarkers;
            next.push({
                ratio,
                type: Math.floor(Math.random() * 3),
                opacity: 1,
                state: 'stay',
                timer: Math.random() * 100 + 50
            });
        }
        markers = next;
    }

    for (let i = markers.length - 1; i >= 0; i--) {
        let m = markers[i];
        if (m.state === 'stay') {
            m.timer--;
            if (m.timer <= 0) m.state = 'out';
        } else if (m.state === 'out') {
            m.opacity -= 0.03;
            if (m.opacity <= 0) {
                markers.splice(i, 1);
            }
        }
    }
}

function updatePath() {
    pathPoints = [];
    const speed = parseFloat(ui.speed.value);
    const range = parseFloat(ui.range.value) / 100;
    const areaW = width * range;
    const areaH = height * range;
    const minX = (width - areaW) / 2;
    const minY = (height - areaH) / 2;
    const maxX = minX + areaW;
    const maxY = minY + areaH;
    anchors.forEach(p => {
        p.x += p.vx * speed;
        p.y += p.vy * speed;
        if (p.x < minX) { p.x = minX; p.vx = Math.abs(p.vx); }
        if (p.x > maxX) { p.x = maxX; p.vx = -Math.abs(p.vx); }
        if (p.y < minY) { p.y = minY; p.vy = Math.abs(p.vy); }
        if (p.y > maxY) { p.y = maxY; p.vy = -Math.abs(p.vy); }
        p.x = Math.max(0, Math.min(width, p.x));
        p.y = Math.max(0, Math.min(height, p.y));
    });

    const detail = parseInt(ui.detail.value, 10);
    if (detail === 0 && anchors.length >= 2) {
        const p1 = anchors[0];
        const p2 = anchors[1];
        for (let t = 0; t <= 1; t += 0.02) {
            pathPoints.push({
                x: p1.x + (p2.x - p1.x) * t,
                y: p1.y + (p2.y - p1.y) * t
            });
        }
        return;
    }

    const organic = Math.max(0, Math.min(1, parseInt(ui.organic.value, 10) / 100));
    const quality = parseInt(ui.quality.value, 10);
    const step = 0.03 / Math.max(1, quality);
    for (let i = 0; i < anchors.length; i++) {
        const p0 = anchors[i === 0 ? anchors.length - 1 : i - 1];
        const p1 = anchors[i];
        const p2 = anchors[(i + 1) % anchors.length];
        const p3 = anchors[(i + 2) % anchors.length];

        for (let t = 0; t <= 1; t += step) {
            const cx = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t * t + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t * t * t);
            const cy = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t * t + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t * t * t);
            const lx = p1.x + (p2.x - p1.x) * t;
            const ly = p1.y + (p2.y - p1.y) * t;
            const x = lx + (cx - lx) * organic;
            const y = ly + (cy - ly) * organic;
            pathPoints.push({ x, y });
        }
    }
}

function draw() {
    const trail = parseFloat(ui.trail.value);
    const clearAlpha = Math.max(0.05, 1 - trail);
    ctx.globalAlpha = clearAlpha;
    ctx.fillStyle = BG;
    ctx.fillRect(0, 0, width, height);
    ctx.globalAlpha = 1;
    if (bgImage) {
        const scale = Math.min(width / bgImage.width, height / bgImage.height);
        const w = bgImage.width * scale;
        const h = bgImage.height * scale;
        const x = (width - w) / 2;
        const y = (height - h) / 2;
        ctx.drawImage(bgImage, x, y, w, h);
    }

    const style = parseInt(ui.lineStyle.value, 10);
    const quality = parseInt(ui.quality.value, 10);
    const stride = Math.max(1, 5 - quality);
    const baseStroke = parseFloat(ui.stroke.value);
    const breath = parseFloat(ui.breath.value);
    const breathe = 1 + breath * 0.25 * Math.sin(timeSec * 2.1);
    const strokeW = baseStroke * breathe;
    const pts = pathPoints;
    const gradOn = ui.gradient.checked;
    const gradSpeed = parseFloat(ui.gradSpeed.value);
    const gradDepth = parseFloat(ui.gradDepth.value);
    const hueBase = (timeSec * 60 * gradSpeed) % 360;
    const colorAt = (t) => {
        if (!gradOn) return FG;
        const l = 50 + Math.sin((t + timeSec * 0.2 * gradSpeed) * Math.PI * 2) * (gradDepth * 30);
        return `hsl(${hueBase}, 90%, ${Math.max(10, Math.min(90, l))}%)`;
    };

    const jitter = parseFloat(ui.lineJitter.value);
    const linePts = (jitter > 0 && pts.length > 0) ? pts.map((p, i) => {
        const jx = Math.sin(i * 0.23 + timeSec * 2.3) * jitter * strokeW * 0.6;
        const jy = Math.cos(i * 0.19 + timeSec * 2.1) * jitter * strokeW * 0.6;
        return { x: p.x + jx, y: p.y + jy };
    }) : pts;
    const renderPts = (() => {
        if (stride <= 1) return linePts;
        const out = [];
        for (let i = 0; i < linePts.length; i += stride) out.push(linePts[i]);
        const last = linePts[linePts.length - 1];
        const tail = out[out.length - 1];
        if (!tail || tail.x !== last.x || tail.y !== last.y) out.push(last);
        return out;
    })();

    const makeOffsetPoints = (offset, inPts) => {
        const out = [];
        for (let i = 0; i < inPts.length; i++) {
            const p0 = inPts[i - 1] || inPts[i];
            const p1 = inPts[i];
            const p2 = inPts[i + 1] || inPts[i];
            const dx = p2.x - p0.x;
            const dy = p2.y - p0.y;
            const len = Math.hypot(dx, dy) || 1;
            const nx = -dy / len;
            const ny = dx / len;
            out.push({ x: p1.x + nx * offset, y: p1.y + ny * offset });
        }
        return out;
    };

    const drawSolid = (inPts, w, alpha) => {
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        if (gradOn) {
            for (let i = 1; i < inPts.length; i++) {
                const p0 = inPts[i - 1];
                const p1 = inPts[i];
                ctx.strokeStyle = colorAt(i / (inPts.length - 1));
                ctx.lineWidth = w;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.stroke();
            }
            ctx.strokeStyle = colorAt(0);
            ctx.lineWidth = w;
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.moveTo(inPts[inPts.length - 1].x, inPts[inPts.length - 1].y);
            ctx.lineTo(inPts[0].x, inPts[0].y);
            ctx.stroke();
        } else {
            ctx.strokeStyle = colorAt(0.5);
            ctx.lineWidth = w;
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.moveTo(inPts[0].x, inPts[0].y);
            inPts.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.stroke();
        }
    };

    if (ui.lineToggle?.checked && renderPts.length > 1) {
        const layers = parseInt(ui.layers.value, 10);
        const totalLayers = Math.max(1, layers);
        for (let l = 0; l < totalLayers; l++) {
            const layerT = totalLayers === 1 ? 0.5 : l / (totalLayers - 1);
            const alpha = totalLayers === 1 ? 1 : (0.8 - layerT * 0.5);
            const offset = totalLayers === 1 ? 0 : (l - (totalLayers - 1) / 2) * strokeW * 0.6;
            const ptsLayer = offset === 0 ? renderPts : makeOffsetPoints(offset, renderPts);

            if (style === 1) {
                const step = Math.max(3, Math.round(10 - strokeW * 2));
                ctx.globalAlpha = alpha;
                for (let i = 0; i < ptsLayer.length; i += step) {
                    const p = ptsLayer[i];
                    ctx.fillStyle = colorAt(i / (ptsLayer.length - 1));
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, strokeW * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (style === 2) {
                ctx.strokeStyle = colorAt(layerT);
                ctx.globalAlpha = alpha;
                ctx.lineWidth = strokeW;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.setLineDash([strokeW * 4, strokeW * 3]);
                ctx.beginPath();
                ctx.moveTo(ptsLayer[0].x, ptsLayer[0].y);
                ptsLayer.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.lineTo(ptsLayer[0].x, ptsLayer[0].y);
                ctx.stroke();
                ctx.setLineDash([]);
            } else if (style === 3) {
                const step = Math.max(3, Math.round(8 - strokeW));
                ctx.globalAlpha = alpha;
                const s = strokeW * 1.2;
                for (let i = 0; i < ptsLayer.length; i += step) {
                    const p = ptsLayer[i];
                    ctx.fillStyle = colorAt(i / (ptsLayer.length - 1));
                    ctx.fillRect(p.x - s * 0.5, p.y - s * 0.5, s, s);
                }
            } else if (style === 4) {
                ctx.strokeStyle = colorAt(layerT);
                ctx.lineWidth = strokeW * 1.6;
                ctx.globalAlpha = alpha * 0.5;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.beginPath();
                ctx.moveTo(ptsLayer[0].x, ptsLayer[0].y);
                ptsLayer.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.lineTo(ptsLayer[0].x, ptsLayer[0].y);
                ctx.stroke();
                drawSolid(ptsLayer, strokeW, alpha);
            } else if (style === 5) {
                const step = Math.max(2, Math.round(6 - strokeW * 0.5));
                ctx.globalAlpha = alpha;
                for (let i = 0; i < ptsLayer.length; i += step) {
                    const p = ptsLayer[i];
                    ctx.fillStyle = colorAt(i / (ptsLayer.length - 1));
                    ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
                }
            } else if (style === 6) {
                ctx.globalAlpha = alpha;
                for (let i = 1; i < ptsLayer.length; i += 6) {
                    const p0 = ptsLayer[i - 1];
                    const p1 = ptsLayer[i];
                    const w = strokeW * (0.4 + 0.6 * ((i / 6) % 2));
                    ctx.strokeStyle = colorAt(i / (ptsLayer.length - 1));
                    ctx.lineWidth = w;
                    ctx.beginPath();
                    ctx.moveTo(p0.x, p0.y);
                    ctx.lineTo(p1.x, p1.y);
                    ctx.stroke();
                }
            } else if (style === 7) {
                const amp = strokeW * 1.2;
                const offsetPts = makeOffsetPoints(amp, ptsLayer);
                ctx.strokeStyle = colorAt(layerT);
                ctx.lineWidth = strokeW;
                ctx.globalAlpha = alpha;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.beginPath();
                ctx.moveTo(ptsLayer[0].x, ptsLayer[0].y);
                for (let i = 1; i < ptsLayer.length; i++) {
                    const p = (i % 2 === 0) ? offsetPts[i] : ptsLayer[i];
                    ctx.lineTo(p.x, p.y);
                }
                ctx.lineTo(ptsLayer[0].x, ptsLayer[0].y);
                ctx.stroke();
            } else if (style === 8) {
                const off = strokeW * 0.9;
                const a = makeOffsetPoints(off, ptsLayer);
                const b = makeOffsetPoints(-off, ptsLayer);
                ctx.strokeStyle = colorAt(layerT);
                ctx.globalAlpha = alpha;
                ctx.lineWidth = Math.max(1, strokeW * 0.6);
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.beginPath();
                ctx.moveTo(a[0].x, a[0].y);
                a.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.lineTo(a[0].x, a[0].y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(b[0].x, b[0].y);
                b.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.lineTo(b[0].x, b[0].y);
                ctx.stroke();
            } else if (style === 9) {
                ctx.strokeStyle = colorAt(layerT);
                ctx.lineWidth = strokeW;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                for (let i = 0; i < ptsLayer.length; i++) {
                    const p = ptsLayer[i];
                    const jx = (Math.sin(i * 0.35 + 1.7) * strokeW) * 0.25;
                    const jy = (Math.cos(i * 0.27 + 0.9) * strokeW) * 0.25;
                    if (i === 0) ctx.moveTo(p.x + jx, p.y + jy);
                    else ctx.lineTo(p.x + jx, p.y + jy);
                }
                const first = ptsLayer[0];
                const jx0 = (Math.sin(0 * 0.35 + 1.7) * strokeW) * 0.25;
                const jy0 = (Math.cos(0 * 0.27 + 0.9) * strokeW) * 0.25;
                ctx.lineTo(first.x + jx0, first.y + jy0);
                ctx.stroke();
            } else {
                drawSolid(ptsLayer, strokeW, alpha);
            }
            ctx.globalAlpha = 1;
        }
    }

    const drift = parseFloat(ui.nodeDrift.value);
    const interact = ui.nodeInteract.checked;
    const repel = ui.nodeRepel.checked;
    const force = parseFloat(ui.nodeForce.value);
    const radius = parseFloat(ui.nodeRadius.value);

    markers.forEach((m, i) => {
        let idx = Math.floor(m.ratio * (pathPoints.length - 1));
        let p = pathPoints[idx];
        if (p) {
            let x = p.x;
            let y = p.y;
            if (drift > 0) {
                x += Math.sin(i * 0.7 + timeSec * 2.2) * drift * strokeW * 0.8;
                y += Math.cos(i * 0.9 + timeSec * 2.0) * drift * strokeW * 0.8;
            }
            if (interact && mouse.active) {
                const dx = x - mouse.x;
                const dy = y - mouse.y;
                const dist = Math.hypot(dx, dy) || 1;
                if (dist < radius) {
                    const t = 1 - dist / radius;
                    const dir = repel ? 1 : -1;
                    const push = dir * force * t * 80;
                    x += (dx / dist) * push;
                    y += (dy / dist) * push;
                }
            }
            drawMarker(x, y, m.opacity, i);
        }
    });
}

function drawMarker(x, y, opacity, idx) {
    const s = parseFloat(ui.shapeSize.value);
    ctx.save();
    ctx.globalAlpha = opacity; 
    const nodeCol = ui.nodeColor?.value || FG;
    ctx.strokeStyle = nodeCol;
    ctx.lineWidth = parseFloat(ui.nodeStroke.value);
    ctx.fillStyle = nodeCol;
    ctx.font = '10px monospace';

    const shapeIdx = parseInt(ui.shape.value, 10);
    const filled = ui.fill.checked;
    const baseLine = ctx.lineWidth;
    ctx.beginPath();
    if (shapeIdx === 1) {
        ctx.moveTo(x, y - s);
        ctx.lineTo(x + s, y + s);
        ctx.lineTo(x - s, y + s);
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 2) {
        ctx.arc(x, y, s, 0, Math.PI * 2);
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 3) {
        if (filled) {
            ctx.fillRect(x - s, y - s, s * 2, s * 2);
        } else {
            ctx.strokeRect(x - s, y - s, s * 2, s * 2);
        }
    } else if (shapeIdx === 4) {
        const r = s * 0.9;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        filled ? ctx.fill() : ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x - r * 1.1, y);
        ctx.lineTo(x + r * 1.1, y);
        ctx.moveTo(x, y - r * 1.1);
        ctx.lineTo(x, y + r * 1.1);
        ctx.stroke();
        const dotR = r * 0.18;
        ctx.beginPath();
        ctx.arc(x - r * 1.35, y, dotR, 0, Math.PI * 2);
        ctx.arc(x + r * 1.35, y, dotR, 0, Math.PI * 2);
        ctx.fill();
    } else if (shapeIdx === 5) {
        const r = s * 0.9;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        filled ? ctx.fill() : ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x - r * 0.8, y + r * 0.8);
        ctx.lineTo(x + r * 0.8, y - r * 0.8);
        ctx.stroke();
    } else if (shapeIdx === 6) {
        const r = s * 0.95;
        ctx.strokeRect(x - r, y - r, r * 2, r * 2);
        const inner = r * 0.35;
        ctx.fillRect(x - inner, y - inner, inner * 2, inner * 2);
    } else if (shapeIdx === 7) {
        ctx.beginPath();
        ctx.moveTo(x, y - s);
        ctx.lineTo(x + s, y);
        ctx.lineTo(x, y + s);
        ctx.lineTo(x - s, y);
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 8) {
        const r = s;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (Math.PI / 3) * i - Math.PI / 6;
            const px = x + Math.cos(a) * r;
            const py = y + Math.sin(a) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 9) {
        const r1 = s;
        const r2 = s * 0.45;
        ctx.beginPath();
        for (let i = 0; i < 10; i++) {
            const a = (Math.PI / 5) * i - Math.PI / 2;
            const r = i % 2 === 0 ? r1 : r2;
            const px = x + Math.cos(a) * r;
            const py = y + Math.sin(a) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 10) {
        const r = s;
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
            const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
            const px = x + Math.cos(a) * r;
            const py = y + Math.sin(a) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 11) {
        const r = s;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const a = (Math.PI * 2 / 8) * i - Math.PI / 8;
            const px = x + Math.cos(a) * r;
            const py = y + Math.sin(a) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 12) {
        const r = s;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.stroke();
        if (filled) {
            ctx.beginPath();
            ctx.arc(x, y, r * 0.45, 0, Math.PI * 2);
            ctx.fill();
        }
    } else if (shapeIdx === 13) {
        ctx.beginPath();
        ctx.moveTo(x - s, y);
        ctx.lineTo(x + s, y);
        ctx.moveTo(x, y - s);
        ctx.lineTo(x, y + s);
        ctx.stroke();
    } else if (shapeIdx === 14) {
        ctx.beginPath();
        ctx.moveTo(x - s, y);
        ctx.lineTo(x + s, y);
        ctx.stroke();
    } else if (shapeIdx === 15) {
        ctx.beginPath();
        ctx.moveTo(x, y - s);
        ctx.lineTo(x + s, y + s);
        ctx.lineTo(x - s, y + s);
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 16) {
        ctx.beginPath();
        ctx.moveTo(x, y + s);
        ctx.lineTo(x + s, y - s);
        ctx.lineTo(x - s, y - s);
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 17) {
        const r = s * 0.95;
        ctx.beginPath();
        ctx.moveTo(x, y + r);
        ctx.bezierCurveTo(x - r * 1.2, y + r * 0.2, x - r * 1.2, y - r * 0.6, x, y - r * 0.15);
        ctx.bezierCurveTo(x + r * 1.2, y - r * 0.6, x + r * 1.2, y + r * 0.2, x, y + r);
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 18) {
        const r = s;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x - r * 0.2, y - r * 0.7);
        ctx.lineTo(x - r * 0.2, y - r * 0.25);
        ctx.lineTo(x - r, y - r * 0.25);
        ctx.lineTo(x - r, y + r * 0.25);
        ctx.lineTo(x - r * 0.2, y + r * 0.25);
        ctx.lineTo(x - r * 0.2, y + r * 0.7);
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else {
        ctx.moveTo(x - s, y); ctx.lineTo(x + s, y);
        ctx.moveTo(x, y - s); ctx.lineTo(x, y + s);
        ctx.stroke();
    }
    if (ui.labels.checked) {
        ctx.fillText(`${Math.round(x)} ${Math.round(y)}`, x + 10, y - 10);
    }
    ctx.restore();
}

function animate(now) {
    timeSec = (now || performance.now()) * 0.001;
    if (!paused) {
        updatePath();
        updateMarkers();
        draw();
    }
    requestAnimationFrame(animate);
}

resize();

function regenerate() {
    initAnchors();
    markers = [];
    pathPoints = [];
}
function resetDefaults() {
    document.querySelectorAll(".controls input").forEach(el => {
        if (el.type === "checkbox") {
            el.checked = el.defaultChecked;
        } else if (el.type === "file") {
            el.value = "";
        } else {
            el.value = el.defaultValue;
        }
    });
    bgImage = null;
    syncUI();
    applyTheme();
    syncNodesGroup();
    syncLineGroup();
}
ui.regen.addEventListener("click", () => {
    resetDefaults();
    regenerate();
});

ui.pause.addEventListener("click", () => {
    paused = !paused;
    ui.pause.textContent = paused ? "Play" : "Pause";
});
window.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "r") regenerate();
    if (e.key.toLowerCase() === "h") {
        const panel = document.querySelector(".ui");
        if (panel) panel.classList.toggle("is-hidden");
    }
    if (e.key === " ") {
        e.preventDefault();
        paused = !paused;
        ui.pause.textContent = paused ? "Play" : "Pause";
    }
});

ui.download.addEventListener("click", () => {
    const scale = 2;
    const off = document.createElement("canvas");
    off.width = canvas.width * scale;
    off.height = canvas.height * scale;
    const octx = off.getContext("2d");
    octx.scale(scale, scale);
    octx.drawImage(canvas, 0, 0);

    const link = document.createElement("a");
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    link.download = `dot10_${ts}_${scale}x.png`;
    link.href = off.toDataURL("image/png", 1.0);
    link.click();
});

animate();
</script>
    <div class="credit">Designed and developed by © <a href="https://luoooif.com" target="_blank" rel="noopener">Yifei Luo</a></div>
</body>
</html>
